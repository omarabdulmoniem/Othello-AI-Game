def get_valid_moves(board, player):
    valid_moves = []

    # Check each cell of the board
    for i in range(len(board)):
        for j in range(len(board[i])):
            # If the cell is empty, check if it's a valid move
            if board[i][j] == 0:
                # Check in all eight directions
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        if dx == 0 and dy == 0:
                            continue  # Skip the current cell

                        # Move in the current direction until a different player's piece is found or the edge of the board is reached
                        x, y = i + dx, j + dy
                        path = []  # Stores the path of opponent's pieces

                        while 0 <= x < len(board) and 0 <= y < len(board[x]):
                            if board[x][y] == -player:
                                path.append((x, y))
                                x += dx
                                y += dy
                            elif board[x][y] == player and path:
                                # If the next cell is the player's own piece and there is a path of opponent's pieces in between, it's a valid move
                                valid_moves.append((i, j))
                                break
                            else:
                                break

    return valid_moves


print(get_valid_moves([ [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, -1, 1, 0, 0, 0],
                        [0, 0, 0, 1, 1, 0, 0, 0],
                        [0, 0, 0, 0, 1, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0]], -1))